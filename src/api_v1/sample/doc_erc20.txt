"EVENTS\nTransfer(from, to, value)\n\nApproval(owner, spender, value)\n\ntotalSupply() → uint256\nexternal\nReturns the amount of tokens in existence.\n\nbalanceOf(address account) → uint256\nexternal\nReturns the amount of tokens owned by account.\n\ntransfer(address recipient, uint256 amount) → bool\nexternal\nMoves amount tokens from the caller’s account to recipient.\n\nReturns a boolean value indicating whether the operation succeeded.\n\nEmits a Transfer event.\n\nallowance(address owner, address spender) → uint256\nexternal\nReturns the remaining number of tokens that spender will be allowed to spend on behalf of owner through transferFrom. This is zero by default.\n\nThis value changes when approve or transferFrom are called.\n\napprove(address spender, uint256 amount) → bool\nexternal\nSets amount as the allowance of spender over the caller’s tokens.\n\nReturns a boolean value indicating whether the operation succeeded.\n\nBeware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender’s allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\nEmits an Approval event.\n\ntransferFrom(address sender, address recipient, uint256 amount) → bool\nexternal\nMoves amount tokens from sender to recipient using the allowance mechanism. amount is then deducted from the caller’s allowance.\n\nReturns a boolean value indicating whether the operation succeeded.\n\nEmits a Transfer event.\n\nTransfer(address from, address to, uint256 value)\nevent\nEmitted when value tokens are moved from one account (from) to another (to).\n\nNote that value may be zero.\n\nApproval(address owner, address spender, uint256 value)\nevent\nEmitted when the allowance of a spender for an owner is set by a call to approve. value is the new allowance.\n\n"
